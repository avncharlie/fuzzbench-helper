#!/usr/bin/env python3
"""get_fuzzer_speeds.py

Generate throughput statistics, CSV summaries, pretty‑printed text, and a
bar‑chart (PNG) for FuzzBench experiments **or** from a previously generated
CSV file.

Usage examples
--------------
Parse a FuzzBench experiment directory (creates CSV and PNG)::

    ./throughput_summary.py --exp-dir ~/fb-data/my_exp

Render a chart from an existing CSV (no need for the experiments folder)::

    ./throughput_summary.py --csv ~/fb-data/my_exp/throughput.csv
"""

from __future__ import annotations

import sys
import tarfile
import argparse
import statistics
import csv
from collections import defaultdict
from pathlib import Path
from typing import Dict, Tuple, List

# ── plotting ──────────────────────────────────────────────────────────────
import matplotlib

matplotlib.use("Agg")  # so the script works on head‑less servers
import matplotlib.pyplot as plt
import numpy as np
# ───────────────────────────────────────────────────────────────────────────

# ---- colour helpers -------------------------------------------------------
RESET = "\033[0m"
BOLD = "\033[1m"
CYAN = "\033[36m"  # headers
MAGENTA = "\033[35m"  # fuzzer names
GREEN = "\033[32m"  # fastest fuzzer for a benchmark
YELLOW = "\033[33m"  # everyone else
# --------------------------------------------------------------------------

DBG = False

# Result‑dict type alias
Results = Dict[str, Dict[str, Tuple[List[float], float, float]]]

# ───────────────────────────────────────────────────────────────────────────
# argument parsing
# ───────────────────────────────────────────────────────────────────────────

def parse_args() -> argparse.Namespace:
    """Return parsed command‑line arguments."""

    global DBG

    p = argparse.ArgumentParser(
        description=(
            "Summarise a FuzzBench experiment OR render statistics from an "
            "existing CSV; always emits a PNG bar‑chart."
        )
    )

    src = p.add_mutually_exclusive_group(required=True)
    src.add_argument(
        "--exp-dir",
        metavar="DIR",
        help="FuzzBench experiment directory (must contain a 'data' subfolder)",
    )
    src.add_argument(
        "--csv",
        dest="csv_path",
        metavar="FILE",
        help="Path to throughput CSV generated by a previous run",
    )

    p.add_argument("--debug", action="store_true", help="Verbose prints for troubleshooting")
    return p.parse_args()


# ───────────────────────────────────────────────────────────────────────────
# helpers for parsing experiment data
# ───────────────────────────────────────────────────────────────────────────

def get_speed_from_fuzzer_stats(stats: str) -> float:
    for line in stats.splitlines():
        if line.strip().startswith("execs_per_sec"):
            return float(line.split(":")[1].strip())
    raise ValueError("'execs_per_sec' not found in fuzzer_stats")


def _trial_speed(trial: Path) -> float | None:
    corpus_dir = trial / "corpus"

    def archive_no(p: Path) -> int:
        return int(p.name.replace(".tar.gz", "").replace("corpus-archive-", ""))

    try:
        tar_archives = filter(
            lambda x: x.name.startswith("corpus-archive-") and x.name.endswith(".tar.gz"),
            corpus_dir.iterdir(),
        )
    except FileNotFoundError:
        return None

    ordered = sorted(tar_archives, key=archive_no, reverse=True)

    for t in ordered:
        with tarfile.open(t, "r:gz") as tf:
            for m in tf.getmembers():
                if m.name.endswith("fuzzer_stats"):
                    if DBG:
                        print(f"Found fuzzer_stats in {t}")
                    stats = tf.extractfile(m).read().decode()
                    return get_speed_from_fuzzer_stats(stats)
    return None


def _experiment_results(base_dir: Path) -> Results:
    """Return results dict parsed from *base_dir* (.experiment-folders)."""

    results: Results = defaultdict(dict)

    for folder in filter(Path.is_dir, base_dir.iterdir()):
        fuzzer = folder.name.split("-")[-1]
        benchmark = folder.name[: -(len(fuzzer) + 1)]
        trial_vals = [_trial_speed(p) for p in folder.iterdir() if p.is_dir()]
        trial_vals = [v for v in trial_vals if v is not None]

        if not trial_vals:
            print(f"{folder.name} has no data yet — skipping…")
            continue

        mean = statistics.mean(trial_vals)
        stdev = statistics.stdev(trial_vals) if len(trial_vals) > 1 else 0.0
        results[benchmark][fuzzer] = (trial_vals, mean, stdev)

    return results


# ───────────────────────────────────────────────────────────────────────────
# CSV I/O
# ───────────────────────────────────────────────────────────────────────────

def write_csv(results: Results, out_path: Path) -> None:
    """Write *results* as CSV to *out_path*."""

    with out_path.open("w", newline="") as f:
        w = csv.writer(f)
        w.writerow(["benchmark", "fuzzer", "mean", "stdev", "num_trials", "trials"])
        for benchmark in sorted(results):
            for fuzzer in sorted(results[benchmark]):
                trials, mean, stdev = results[benchmark][fuzzer]
                w.writerow(
                    [
                        benchmark,
                        fuzzer,
                        f"{mean:.2f}",
                        f"{stdev:.2f}",
                        len(trials),
                        " ".join(f"{t:.2f}" for t in trials),
                    ]
                )


def read_csv(csv_path: Path) -> Results:
    """Return a results dict parsed from *csv_path*."""

    results: Results = defaultdict(dict)

    with csv_path.open(newline="") as f:
        rdr = csv.DictReader(f)
        for row in rdr:
            benchmark = row["benchmark"]
            fuzzer = row["fuzzer"]
            mean = float(row["mean"])
            stdev = float(row["stdev"])
            trials = [float(x) for x in row.get("trials", "").split()] if row.get("trials") else []
            results[benchmark][fuzzer] = (trials, mean, stdev)
    return results


# ───────────────────────────────────────────────────────────────────────────
# presentation helpers
# ───────────────────────────────────────────────────────────────────────────

def pretty_print(results: Results) -> None:
    """Emit colourful text summary to stdout."""

    for benchmark, fuzzers_dict in results.items():
        print(f"{BOLD}{CYAN}{benchmark}{RESET}")
        # sort fuzzers by mean exec/sec (desc)
        fuzzers_sorted = sorted(fuzzers_dict, key=lambda f: fuzzers_dict[f][1], reverse=True)
        fastest = fuzzers_sorted[0]

        for fuzzer in fuzzers_sorted:
            trials, mean, stdev = fuzzers_dict[fuzzer]
            colour = GREEN if fuzzer == fastest else YELLOW
            stdev_part = f", σ {stdev:.2f}" if stdev else ""
            plural = "trial" if len(trials) == 1 else "trials"

            print(
                f"  {MAGENTA}{fuzzer}{RESET}: "
                f"{colour}{mean:.2f}{RESET} exec/s "
                f"({len(trials)} {plural}{stdev_part}). "
                f"Trials → {trials}"
            )


# ───────────────────────────────────────────────────────────────────────────
# chart generation
# ───────────────────────────────────────────────────────────────────────────

def emit_chart(results: Results, out_path: Path, show: bool = False) -> None:
    """Create a grouped bar‑chart and save it to *out_path*."""

    benchmarks = sorted(results.keys())
    fuzzers = sorted({f for v in results.values() for f in v.keys()})

    means = np.full((len(benchmarks), len(fuzzers)), np.nan)
    stds = np.full_like(means, np.nan)

    for bi, bench in enumerate(benchmarks):
        for fi, fuzzer in enumerate(fuzzers):
            if fuzzer in results[bench]:
                _, mean, std = results[bench][fuzzer]
                means[bi, fi] = mean
                stds[bi, fi] = std

    x = np.arange(len(benchmarks))
    width = 0.8 / len(fuzzers)
    offsets = (np.arange(len(fuzzers)) - (len(fuzzers) - 1) / 2) * width

    fig, ax = plt.subplots(figsize=(max(10, len(benchmarks) * 1.8), 6))

    for fi, fuzzer in enumerate(fuzzers):
        bars = ax.bar(
            x + offsets[fi],
            means[:, fi],
            width,
            label=fuzzer.replace("_", " "),
            yerr=stds[:, fi],
            capsize=4,
        )
        ax.bar_label(bars, fmt="%.1f", padding=3, fontsize=8)

    ax.set_ylabel("Executions per second")
    ax.set_title("Throughput (mean ± σ)")
    ax.set_xticks(x)
    ax.set_xticklabels(benchmarks, rotation=30, ha="right")
    ax.legend(title="Fuzzer")
    fig.tight_layout()
    plt.savefig(out_path, dpi=150)
    if show:
        plt.show()
    plt.close(fig)


# ───────────────────────────────────────────────────────────────────────────
# main logic
# ───────────────────────────────────────────────────────────────────────────

def main() -> None:
    global DBG
    args = parse_args()
    DBG = args.debug

    # ------------------------------------------------------------------
    # data source → results dict
    # ------------------------------------------------------------------
    csv_path = None
    if args.csv_path:
        csv_path = Path(args.csv_path).expanduser().resolve()
        if not csv_path.is_file():
            sys.exit(f"CSV '{csv_path}' not found")
        results = read_csv(csv_path)
        out_base = csv_path.parent
    else:
        exp_dir = Path(args.exp_dir).expanduser().resolve()
        exp_name = exp_dir.name
        base_dir = exp_dir / "data" / exp_name / "experiment-folders"
        if not base_dir.is_dir():
            sys.exit(f"Error: '{base_dir}' does not look like a FuzzBench data folder")

        results = _experiment_results(base_dir)
        if not results:
            sys.exit("No valid trials found — nothing to do.")

        # write CSV next to experiment dir for later reuse
        csv_path = exp_dir / "throughput.csv"
        write_csv(results, csv_path)
        out_base = exp_dir

    # ------------------------------------------------------------------
    # presentation (pretty print + chart)
    # ------------------------------------------------------------------
    pretty_print(results)

    png_path = out_base / "throughput.png"
    emit_chart(results, png_path, show=False)
    print(f"\nChart saved to {png_path}")
    if not args.csv_path:
        print(f"CSV saved to {csv_path}")


if __name__ == "__main__":
    main()

